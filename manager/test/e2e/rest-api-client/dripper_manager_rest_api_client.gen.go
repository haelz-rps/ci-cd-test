// Package restapiclient_test provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package restapiclient_test

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AsyncRequestStatusEnum.
const (
	AsyncRequestStatusEnumFailed   AsyncRequestStatusEnum = "failed"
	AsyncRequestStatusEnumFinished AsyncRequestStatusEnum = "finished"
	AsyncRequestStatusEnumPending  AsyncRequestStatusEnum = "pending"
)

// Defines values for GetSourceTablesStatusStatus.
const (
	GetSourceTablesStatusStatusFailed   GetSourceTablesStatusStatus = "failed"
	GetSourceTablesStatusStatusFinished GetSourceTablesStatusStatus = "finished"
	GetSourceTablesStatusStatusPending  GetSourceTablesStatusStatus = "pending"
)

// Defines values for JobStatus.
const (
	Cancelled  JobStatus = "cancelled"
	Failed     JobStatus = "failed"
	Incomplete JobStatus = "incomplete"
	Pending    JobStatus = "pending"
	Running    JobStatus = "running"
	Succeeded  JobStatus = "succeeded"
)

// Defines values for ScheduleType.
const (
	Basic  ScheduleType = "basic"
	Cron   ScheduleType = "cron"
	Manual ScheduleType = "manual"
)

// AsyncOperationResponse defines model for AsyncOperationResponse.
type AsyncOperationResponse struct {
	TicketId openapi_types.UUID `json:"ticketId"`
}

// AsyncRequestStatusEnum Enum that describes the status of an async request.
type AsyncRequestStatusEnum string

// BasicSchedule defines model for BasicSchedule.
type BasicSchedule struct {
	TimeUnit *string `json:"timeUnit,omitempty"`
	Units    *int    `json:"units,omitempty"`
}

// ConnectionSpecificationProperty defines model for ConnectionSpecificationProperty.
type ConnectionSpecificationProperty struct {
	// AirbyteSecret If this value is a secret or not
	AirbyteSecret *bool `json:"airbyte_secret,omitempty"`

	// Const Constant value to use if this value is a constant
	Const *string `json:"const,omitempty"`

	// Default Default value to show already filled
	Default *int `json:"default,omitempty"`

	// Description Property description
	Description *string `json:"description,omitempty"`

	// Enum List of allowed values to use, the type will be the same as the property type
	Enum *[]string `json:"enum,omitempty"`

	// Examples List of example values to use, the type will be the same as the property type
	Examples *[]string `json:"examples,omitempty"`

	// Format Data format to use, normally appears only for date types
	Format *string `json:"format,omitempty"`

	// Items List of values to add, this type will only be used if the type of the property is array
	Items *struct {
		// Enum List of allowed values to use, the type will be the same as the property type
		Enum *[]string `json:"enum,omitempty"`

		// Type Data type of the property
		Type *string `json:"type,omitempty"`
	} `json:"items,omitempty"`

	// Order Order to show this property when rendering the configuration screen
	Order *int `json:"order,omitempty"`

	// Pattern Regex to apply to show the date when using format 'date'
	Pattern *string `json:"pattern,omitempty"`

	// Title Property name
	Title *string `json:"title,omitempty"`

	// Type Data type of the property, allowed values are string, integer, boolean and array
	Type *string `json:"type,omitempty"`

	// UniqueItems Flag to describe if we should allow repeated items when dealing with array properties
	UniqueItems *bool `json:"uniqueItems,omitempty"`
}

// Connector defines model for Connector.
type Connector struct {
	DestinationConfiguration *Json                 `json:"destinationConfiguration"`
	Id                       openapi_types.UUID    `json:"id"`
	Name                     string                `json:"name"`
	ResourceRequirements     *ResourceRequirements `json:"resourceRequirements,omitempty"`
	Schedule                 *Schedule             `json:"schedule,omitempty"`

	// ScheduleType determine how the schedule data should be interpreted
	ScheduleType        ScheduleType       `json:"scheduleType"`
	SourceConfiguration *Json              `json:"sourceConfiguration"`
	SourceId            openapi_types.UUID `json:"sourceId"`
	Tables              []Table            `json:"tables"`
	WarehouseDatabase   string             `json:"warehouseDatabase"`
}

// ConnectorsPaginated defines model for ConnectorsPaginated.
type ConnectorsPaginated = []Connector

// CreateConnectorRequestBody defines model for CreateConnectorRequestBody.
type CreateConnectorRequestBody struct {
	// Name Connector name
	Name     string    `json:"name"`
	Schedule *Schedule `json:"schedule,omitempty"`

	// ScheduleType determine how the schedule data should be interpreted
	ScheduleType ScheduleType `json:"scheduleType"`
	Tables       []Table      `json:"tables"`
}

// CreateSourceRequestBody defines model for CreateSourceRequestBody.
type CreateSourceRequestBody struct {
	// Configuration Property object to be generated on the client based on the source schema
	Configuration *map[string]interface{} `json:"configuration,omitempty"`

	// Name Connector name
	Name *string `json:"name,omitempty"`
}

// CreateSourceStatus defines model for CreateSourceStatus.
type CreateSourceStatus struct {
	Error    *string             `json:"error"`
	SourceId *openapi_types.UUID `json:"sourceId"`

	// Status Enum that describes the status of an async request.
	Status AsyncRequestStatusEnum `json:"status"`
}

// CreateWorkspaceRequestBody defines model for CreateWorkspaceRequestBody.
type CreateWorkspaceRequestBody struct {
	Bucket string `json:"bucket"`
	Tenant string `json:"tenant"`
}

// CronSchedule defines model for CronSchedule.
type CronSchedule struct {
	Expression *string `json:"expression,omitempty"`
	TimeZone   *string `json:"timeZone,omitempty"`
}

// GetSourceTablesStatus defines model for GetSourceTablesStatus.
type GetSourceTablesStatus struct {
	Error  *string                     `json:"error"`
	Status GetSourceTablesStatusStatus `json:"status"`
	Tables *TableList                  `json:"tables"`
}

// GetSourceTablesStatusStatus defines model for GetSourceTablesStatus.Status.
type GetSourceTablesStatusStatus string

// Job defines model for Job.
type Job struct {
	BytesSynced *int64     `json:"bytesSynced,omitempty"`
	CreatedAt   *int64     `json:"createdAt,omitempty"`
	Id          *JobId     `json:"id,omitempty"`
	RowsSynced  *int64     `json:"rowsSynced,omitempty"`
	Status      *JobStatus `json:"status,omitempty"`
	UpdatedAt   *int64     `json:"updatedAt,omitempty"`
}

// JobId defines model for JobId.
type JobId = int64

// JobList defines model for JobList.
type JobList = []Job

// JobLog defines model for JobLog.
type JobLog = []string

// JobStatus defines model for JobStatus.
type JobStatus string

// Json defines model for Json.
type Json map[string]interface{}

// ResourceRequirements defines model for ResourceRequirements.
type ResourceRequirements struct {
	CpuLimit      *string `json:"cpuLimit,omitempty"`
	CpuRequest    *string `json:"cpuRequest,omitempty"`
	MemoryLimit   *string `json:"memoryLimit,omitempty"`
	MemoryRequest *string `json:"memoryRequest,omitempty"`
}

// Schedule defines model for Schedule.
type Schedule struct {
	BasicSchedule *BasicSchedule `json:"basicSchedule,omitempty"`
	CronSchedule  *CronSchedule  `json:"cronSchedule,omitempty"`
}

// ScheduleType determine how the schedule data should be interpreted
type ScheduleType string

// SingleConnectionSpecification defines model for SingleConnectionSpecification.
type SingleConnectionSpecification struct {
	Properties *SingleConnectionSpecification_Properties `json:"properties,omitempty"`

	// Required List of fields required
	Required             *[]string              `json:"required,omitempty"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SingleConnectionSpecification_Properties defines model for SingleConnectionSpecification.Properties.
type SingleConnectionSpecification_Properties struct {
	SampleProperty       *ConnectionSpecificationProperty `json:"sample_property,omitempty"`
	AdditionalProperties map[string]interface{}           `json:"-"`
}

// Source defines model for Source.
type Source struct {
	Configuration      *Json               `json:"configuration"`
	DocumentationUrl   *string             `json:"documentationUrl,omitempty"`
	Icon               *string             `json:"icon,omitempty"`
	Name               *string             `json:"name,omitempty"`
	SourceDefinitionId *openapi_types.UUID `json:"sourceDefinitionId,omitempty"`
	SourceId           openapi_types.UUID  `json:"sourceId"`
}

// SourceDefinition defines model for SourceDefinition.
type SourceDefinition struct {
	DocumentationUrl   *string            `json:"documentationUrl,omitempty"`
	Icon               string             `json:"icon"`
	Name               string             `json:"name"`
	SourceDefinitionId openapi_types.UUID `json:"sourceDefinitionId"`
}

// SourceDefinitionConfiguration defines model for SourceDefinitionConfiguration.
type SourceDefinitionConfiguration struct {
	DocumentationUrl    *string                                           `json:"documentationUrl,omitempty"`
	SourceConfiguration SourceDefinitionConfiguration_SourceConfiguration `json:"sourceConfiguration"`
	SourceDefinitionId  openapi_types.UUID                                `json:"sourceDefinitionId"`
}

// SourceDefinitionConfiguration_SourceConfiguration_Properties defines model for SourceDefinitionConfiguration.SourceConfiguration.Properties.
type SourceDefinitionConfiguration_SourceConfiguration_Properties struct {
	SampleArray                 *map[string]interface{}          `json:"sample_array,omitempty"`
	SampleArrayEnum             *map[string]interface{}          `json:"sample_array_enum,omitempty"`
	SampleEnum                  *map[string]interface{}          `json:"sample_enum,omitempty"`
	SampleInteger               *map[string]interface{}          `json:"sample_integer,omitempty"`
	SamplePropertyWithAllFields *ConnectionSpecificationProperty `json:"sample_property_with_all_fields,omitempty"`
	SampleString                *map[string]interface{}          `json:"sample_string,omitempty"`
	AdditionalProperties        map[string]interface{}           `json:"-"`
}

// SourceDefinitionConfiguration_SourceConfiguration defines model for SourceDefinitionConfiguration.SourceConfiguration.
type SourceDefinitionConfiguration_SourceConfiguration struct {
	OneOf      *[]SingleConnectionSpecification                              `json:"oneOf,omitempty"`
	Properties *SourceDefinitionConfiguration_SourceConfiguration_Properties `json:"properties,omitempty"`

	// Required List of fields required
	Required             *[]string              `json:"required,omitempty"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SourceDefinitionList defines model for SourceDefinitionList.
type SourceDefinitionList = []SourceDefinition

// SourceList defines model for SourceList.
type SourceList = []Source

// SuccessfulJobWebhookPayload defines model for SuccessfulJobWebhookPayload.
type SuccessfulJobWebhookPayload struct {
	Data *struct {
		BytesCommitted          *int    `json:"bytesCommitted,omitempty"`
		BytesCommittedFormatted *string `json:"bytesCommittedFormatted,omitempty"`
		BytesEmitted            *int    `json:"bytesEmitted,omitempty"`
		BytesEmittedFormatted   *string `json:"bytesEmittedFormatted,omitempty"`
		Connection              *struct {
			Id   *openapi_types.UUID `json:"id,omitempty"`
			Name *string             `json:"name,omitempty"`
			Url  *string             `json:"url,omitempty"`
		} `json:"connection,omitempty"`
		Destination *struct {
			Id   *openapi_types.UUID `json:"id,omitempty"`
			Name *string             `json:"name,omitempty"`
			Url  *string             `json:"url,omitempty"`
		} `json:"destination,omitempty"`
		DurationFormatted *string    `json:"durationFormatted,omitempty"`
		DurationInSeconds *int       `json:"durationInSeconds,omitempty"`
		FinishedAt        *time.Time `json:"finishedAt,omitempty"`
		JobId             *int       `json:"jobId,omitempty"`
		RecordsCommitted  *int       `json:"recordsCommitted,omitempty"`
		RecordsEmitted    *int       `json:"recordsEmitted,omitempty"`
		Source            *struct {
			Id   *openapi_types.UUID `json:"id,omitempty"`
			Name *string             `json:"name,omitempty"`
			Url  *string             `json:"url,omitempty"`
		} `json:"source,omitempty"`
		StartedAt *time.Time `json:"startedAt,omitempty"`
		Success   *bool      `json:"success,omitempty"`
		Workspace *struct {
			Id   *openapi_types.UUID `json:"id,omitempty"`
			Name *string             `json:"name,omitempty"`
			Url  *string             `json:"url,omitempty"`
		} `json:"workspace,omitempty"`
	} `json:"data,omitempty"`
}

// Table defines model for Table.
type Table struct {
	DefaultCursorField      []string  `json:"defaultCursorField"`
	JsonSchema              *Json     `json:"jsonSchema"`
	Name                    string    `json:"name"`
	Namespace               *string   `json:"namespace,omitempty"`
	SelectedCursorField     *[]string `json:"selectedCursorField,omitempty"`
	SourceDefinedCursor     bool      `json:"sourceDefinedCursor"`
	SourceDefinedPrimaryKey []string  `json:"sourceDefinedPrimaryKey"`
	SupportedSyncModes      []string  `json:"supportedSyncModes"`
	SyncEnabled             bool      `json:"syncEnabled"`
}

// TableList defines model for TableList.
type TableList = []Table

// UpdateSourceStatus defines model for UpdateSourceStatus.
type UpdateSourceStatus struct {
	Error  *string `json:"error"`
	Source *Source `json:"source,omitempty"`

	// Status Enum that describes the status of an async request.
	Status AsyncRequestStatusEnum `json:"status"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	Id   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`
}

// WorkspaceList defines model for WorkspaceList.
type WorkspaceList = []Workspace

// ListWorkspacesParams defines parameters for ListWorkspaces.
type ListWorkspacesParams struct {
	// Limit Number of items to list
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before listing the results
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// NameContains Some substring of the workspace name to search for
	NameContains *string `form:"nameContains,omitempty" json:"nameContains,omitempty"`
}

// ListConnectorsParams defines parameters for ListConnectors.
type ListConnectorsParams struct {
	// Limit Number of items to list
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before listing the results
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// Limit Number of items to list
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before listing the results
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetJobLogsParams defines parameters for GetJobLogs.
type GetJobLogsParams struct {
	// Limit Number of items to list
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before listing the results
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostSuccesfullJobJSONRequestBody defines body for PostSuccesfullJob for application/json ContentType.
type PostSuccesfullJobJSONRequestBody = SuccessfulJobWebhookPayload

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = CreateWorkspaceRequestBody

// UpdateConnectorJSONRequestBody defines body for UpdateConnector for application/json ContentType.
type UpdateConnectorJSONRequestBody = CreateConnectorRequestBody

// UpdateSourceJSONRequestBody defines body for UpdateSource for application/json ContentType.
type UpdateSourceJSONRequestBody = CreateSourceRequestBody

// CreateConnectorFromSourceJSONRequestBody defines body for CreateConnectorFromSource for application/json ContentType.
type CreateConnectorFromSourceJSONRequestBody = CreateConnectorRequestBody

// CreateSourceFromDefinitionJSONRequestBody defines body for CreateSourceFromDefinition for application/json ContentType.
type CreateSourceFromDefinitionJSONRequestBody = CreateSourceRequestBody

// Getter for additional properties for SingleConnectionSpecification. Returns the specified
// element and whether it was found
func (a SingleConnectionSpecification) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SingleConnectionSpecification
func (a *SingleConnectionSpecification) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SingleConnectionSpecification to handle AdditionalProperties
func (a *SingleConnectionSpecification) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["properties"]; found {
		err = json.Unmarshal(raw, &a.Properties)
		if err != nil {
			return fmt.Errorf("error reading 'properties': %w", err)
		}
		delete(object, "properties")
	}

	if raw, found := object["required"]; found {
		err = json.Unmarshal(raw, &a.Required)
		if err != nil {
			return fmt.Errorf("error reading 'required': %w", err)
		}
		delete(object, "required")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SingleConnectionSpecification to handle AdditionalProperties
func (a SingleConnectionSpecification) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Properties != nil {
		object["properties"], err = json.Marshal(a.Properties)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'properties': %w", err)
		}
	}

	if a.Required != nil {
		object["required"], err = json.Marshal(a.Required)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'required': %w", err)
		}
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SingleConnectionSpecification_Properties. Returns the specified
// element and whether it was found
func (a SingleConnectionSpecification_Properties) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SingleConnectionSpecification_Properties
func (a *SingleConnectionSpecification_Properties) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SingleConnectionSpecification_Properties to handle AdditionalProperties
func (a *SingleConnectionSpecification_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["sample_property"]; found {
		err = json.Unmarshal(raw, &a.SampleProperty)
		if err != nil {
			return fmt.Errorf("error reading 'sample_property': %w", err)
		}
		delete(object, "sample_property")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SingleConnectionSpecification_Properties to handle AdditionalProperties
func (a SingleConnectionSpecification_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.SampleProperty != nil {
		object["sample_property"], err = json.Marshal(a.SampleProperty)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sample_property': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SourceDefinitionConfiguration_SourceConfiguration_Properties. Returns the specified
// element and whether it was found
func (a SourceDefinitionConfiguration_SourceConfiguration_Properties) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SourceDefinitionConfiguration_SourceConfiguration_Properties
func (a *SourceDefinitionConfiguration_SourceConfiguration_Properties) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SourceDefinitionConfiguration_SourceConfiguration_Properties to handle AdditionalProperties
func (a *SourceDefinitionConfiguration_SourceConfiguration_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["sample_array"]; found {
		err = json.Unmarshal(raw, &a.SampleArray)
		if err != nil {
			return fmt.Errorf("error reading 'sample_array': %w", err)
		}
		delete(object, "sample_array")
	}

	if raw, found := object["sample_array_enum"]; found {
		err = json.Unmarshal(raw, &a.SampleArrayEnum)
		if err != nil {
			return fmt.Errorf("error reading 'sample_array_enum': %w", err)
		}
		delete(object, "sample_array_enum")
	}

	if raw, found := object["sample_enum"]; found {
		err = json.Unmarshal(raw, &a.SampleEnum)
		if err != nil {
			return fmt.Errorf("error reading 'sample_enum': %w", err)
		}
		delete(object, "sample_enum")
	}

	if raw, found := object["sample_integer"]; found {
		err = json.Unmarshal(raw, &a.SampleInteger)
		if err != nil {
			return fmt.Errorf("error reading 'sample_integer': %w", err)
		}
		delete(object, "sample_integer")
	}

	if raw, found := object["sample_property_with_all_fields"]; found {
		err = json.Unmarshal(raw, &a.SamplePropertyWithAllFields)
		if err != nil {
			return fmt.Errorf("error reading 'sample_property_with_all_fields': %w", err)
		}
		delete(object, "sample_property_with_all_fields")
	}

	if raw, found := object["sample_string"]; found {
		err = json.Unmarshal(raw, &a.SampleString)
		if err != nil {
			return fmt.Errorf("error reading 'sample_string': %w", err)
		}
		delete(object, "sample_string")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SourceDefinitionConfiguration_SourceConfiguration_Properties to handle AdditionalProperties
func (a SourceDefinitionConfiguration_SourceConfiguration_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.SampleArray != nil {
		object["sample_array"], err = json.Marshal(a.SampleArray)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sample_array': %w", err)
		}
	}

	if a.SampleArrayEnum != nil {
		object["sample_array_enum"], err = json.Marshal(a.SampleArrayEnum)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sample_array_enum': %w", err)
		}
	}

	if a.SampleEnum != nil {
		object["sample_enum"], err = json.Marshal(a.SampleEnum)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sample_enum': %w", err)
		}
	}

	if a.SampleInteger != nil {
		object["sample_integer"], err = json.Marshal(a.SampleInteger)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sample_integer': %w", err)
		}
	}

	if a.SamplePropertyWithAllFields != nil {
		object["sample_property_with_all_fields"], err = json.Marshal(a.SamplePropertyWithAllFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sample_property_with_all_fields': %w", err)
		}
	}

	if a.SampleString != nil {
		object["sample_string"], err = json.Marshal(a.SampleString)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sample_string': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SourceDefinitionConfiguration_SourceConfiguration. Returns the specified
// element and whether it was found
func (a SourceDefinitionConfiguration_SourceConfiguration) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SourceDefinitionConfiguration_SourceConfiguration
func (a *SourceDefinitionConfiguration_SourceConfiguration) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SourceDefinitionConfiguration_SourceConfiguration to handle AdditionalProperties
func (a *SourceDefinitionConfiguration_SourceConfiguration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["oneOf"]; found {
		err = json.Unmarshal(raw, &a.OneOf)
		if err != nil {
			return fmt.Errorf("error reading 'oneOf': %w", err)
		}
		delete(object, "oneOf")
	}

	if raw, found := object["properties"]; found {
		err = json.Unmarshal(raw, &a.Properties)
		if err != nil {
			return fmt.Errorf("error reading 'properties': %w", err)
		}
		delete(object, "properties")
	}

	if raw, found := object["required"]; found {
		err = json.Unmarshal(raw, &a.Required)
		if err != nil {
			return fmt.Errorf("error reading 'required': %w", err)
		}
		delete(object, "required")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SourceDefinitionConfiguration_SourceConfiguration to handle AdditionalProperties
func (a SourceDefinitionConfiguration_SourceConfiguration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.OneOf != nil {
		object["oneOf"], err = json.Marshal(a.OneOf)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'oneOf': %w", err)
		}
	}

	if a.Properties != nil {
		object["properties"], err = json.Marshal(a.Properties)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'properties': %w", err)
		}
	}

	if a.Required != nil {
		object["required"], err = json.Marshal(a.Required)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'required': %w", err)
		}
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostSuccesfullJobWithBody request with any body
	PostSuccesfullJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSuccesfullJob(ctx context.Context, body PostSuccesfullJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspaceWithBody request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkspace request
	GetWorkspace(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConnectors request
	ListConnectors(ctx context.Context, workspaceId openapi_types.UUID, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConnector request
	DeleteConnector(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnector request
	GetConnector(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConnectorWithBody request with any body
	UpdateConnectorWithBody(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConnector(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerJobRun request
	TriggerJobRun(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobLogs request
	GetJobLogs(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSources request
	ListSources(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSource request
	DeleteSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSource request
	GetSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSourceWithBody request with any body
	UpdateSourceWithBody(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConnectorFromSourceWithBody request with any body
	CreateConnectorFromSourceWithBody(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConnectorFromSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body CreateConnectorFromSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpdateSourceStatus request
	GetUpdateSourceStatus(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSourceTables request
	GetSourceTables(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGetSourceTablesStatus request
	GetGetSourceTablesStatus(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourcesDefinitions request
	ListSourcesDefinitions(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCreateSourceFromDefinitionStatus request
	GetCreateSourceFromDefinitionStatus(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionID openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSourceDefinitionConfiguration request
	GetSourceDefinitionConfiguration(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSourceFromDefinitionWithBody request with any body
	CreateSourceFromDefinitionWithBody(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSourceFromDefinition(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, body CreateSourceFromDefinitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostSuccesfullJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSuccesfullJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSuccesfullJob(ctx context.Context, body PostSuccesfullJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSuccesfullJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, workspaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkspace(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkspaceRequest(c.Server, workspaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConnectors(ctx context.Context, workspaceId openapi_types.UUID, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConnectorsRequest(c.Server, workspaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConnector(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConnectorRequest(c.Server, workspaceId, connectorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnector(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorRequest(c.Server, workspaceId, connectorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnectorWithBody(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorRequestWithBody(c.Server, workspaceId, connectorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnector(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorRequest(c.Server, workspaceId, connectorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, workspaceId, connectorId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerJobRun(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerJobRunRequest(c.Server, workspaceId, connectorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, workspaceId, connectorId, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobLogs(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobLogsRequest(c.Server, workspaceId, connectorId, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSources(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourcesRequest(c.Server, workspaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSourceRequest(c.Server, workspaceId, sourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourceRequest(c.Server, workspaceId, sourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceWithBody(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequestWithBody(c.Server, workspaceId, sourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequest(c.Server, workspaceId, sourceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnectorFromSourceWithBody(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectorFromSourceRequestWithBody(c.Server, workspaceId, sourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnectorFromSource(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body CreateConnectorFromSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectorFromSourceRequest(c.Server, workspaceId, sourceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpdateSourceStatus(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpdateSourceStatusRequest(c.Server, workspaceId, sourceId, ticketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSourceTables(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourceTablesRequest(c.Server, workspaceId, sourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGetSourceTablesStatus(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGetSourceTablesStatusRequest(c.Server, workspaceId, sourceId, ticketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourcesDefinitions(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourcesDefinitionsRequest(c.Server, workspaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCreateSourceFromDefinitionStatus(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionID openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCreateSourceFromDefinitionStatusRequest(c.Server, workspaceId, sourceDefinitionID, ticketId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSourceDefinitionConfiguration(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourceDefinitionConfigurationRequest(c.Server, workspaceId, sourceDefinitionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceFromDefinitionWithBody(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceFromDefinitionRequestWithBody(c.Server, workspaceId, sourceDefinitionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceFromDefinition(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, body CreateSourceFromDefinitionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceFromDefinitionRequest(c.Server, workspaceId, sourceDefinitionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostSuccesfullJobRequest calls the generic PostSuccesfullJob builder with application/json body
func NewPostSuccesfullJobRequest(server string, body PostSuccesfullJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSuccesfullJobRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSuccesfullJobRequestWithBody generates requests for PostSuccesfullJob with any type of body
func NewPostSuccesfullJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/airbyte_internal/sync_webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string, params *ListWorkspacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameContains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameContains", runtime.ParamLocationQuery, *params.NameContains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, workspaceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkspaceRequest generates requests for GetWorkspace
func NewGetWorkspaceRequest(server string, workspaceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConnectorsRequest generates requests for ListConnectors
func NewListConnectorsRequest(server string, workspaceId openapi_types.UUID, params *ListConnectorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteConnectorRequest generates requests for DeleteConnector
func NewDeleteConnectorRequest(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectorRequest generates requests for GetConnector
func NewGetConnectorRequest(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConnectorRequest calls the generic UpdateConnector builder with application/json body
func NewUpdateConnectorRequest(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConnectorRequestWithBody(server, workspaceId, connectorId, "application/json", bodyReader)
}

// NewUpdateConnectorRequestWithBody generates requests for UpdateConnector with any type of body
func NewUpdateConnectorRequestWithBody(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, params *ListJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors/%s/jobs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerJobRunRequest generates requests for TriggerJobRun
func NewTriggerJobRunRequest(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors/%s/jobs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors/%s/jobs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobLogsRequest generates requests for GetJobLogs
func NewGetJobLogsRequest(server string, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, params *GetJobLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/connectors/%s/jobs/%s/logs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourcesRequest generates requests for ListSources
func NewListSourcesRequest(server string, workspaceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSourceRequest generates requests for DeleteSource
func NewDeleteSourceRequest(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourceRequest generates requests for GetSource
func NewGetSourceRequest(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSourceRequest calls the generic UpdateSource builder with application/json body
func NewUpdateSourceRequest(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body UpdateSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSourceRequestWithBody(server, workspaceId, sourceId, "application/json", bodyReader)
}

// NewUpdateSourceRequestWithBody generates requests for UpdateSource with any type of body
func NewUpdateSourceRequestWithBody(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateConnectorFromSourceRequest calls the generic CreateConnectorFromSource builder with application/json body
func NewCreateConnectorFromSourceRequest(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body CreateConnectorFromSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConnectorFromSourceRequestWithBody(server, workspaceId, sourceId, "application/json", bodyReader)
}

// NewCreateConnectorFromSourceRequestWithBody generates requests for CreateConnectorFromSource with any type of body
func NewCreateConnectorFromSourceRequestWithBody(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources/%s/connectors", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUpdateSourceStatusRequest generates requests for GetUpdateSourceStatus
func NewGetUpdateSourceStatusRequest(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ticketId", runtime.ParamLocationPath, ticketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources/%s/status/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourceTablesRequest generates requests for GetSourceTables
func NewGetSourceTablesRequest(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources/%s/tables", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGetSourceTablesStatusRequest generates requests for GetGetSourceTablesStatus
func NewGetGetSourceTablesStatusRequest(server string, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ticketId", runtime.ParamLocationPath, ticketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources/%s/tables/%s/status", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourcesDefinitionsRequest generates requests for ListSourcesDefinitions
func NewListSourcesDefinitionsRequest(server string, workspaceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources_definitions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCreateSourceFromDefinitionStatusRequest generates requests for GetCreateSourceFromDefinitionStatus
func NewGetCreateSourceFromDefinitionStatusRequest(server string, workspaceId openapi_types.UUID, sourceDefinitionID openapi_types.UUID, ticketId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceDefinitionID", runtime.ParamLocationPath, sourceDefinitionID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ticketId", runtime.ParamLocationPath, ticketId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources_definitions/%s/sources/%s/status", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourceDefinitionConfigurationRequest generates requests for GetSourceDefinitionConfiguration
func NewGetSourceDefinitionConfigurationRequest(server string, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceDefinitionId", runtime.ParamLocationPath, sourceDefinitionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources_definitions/%s/configuration", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSourceFromDefinitionRequest calls the generic CreateSourceFromDefinition builder with application/json body
func NewCreateSourceFromDefinitionRequest(server string, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, body CreateSourceFromDefinitionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSourceFromDefinitionRequestWithBody(server, workspaceId, sourceDefinitionId, "application/json", bodyReader)
}

// NewCreateSourceFromDefinitionRequestWithBody generates requests for CreateSourceFromDefinition with any type of body
func NewCreateSourceFromDefinitionRequestWithBody(server string, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceId", runtime.ParamLocationPath, workspaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceDefinitionId", runtime.ParamLocationPath, sourceDefinitionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingestions/workspaces/%s/sources_definitions/%s/sources", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostSuccesfullJobWithBodyWithResponse request with any body
	PostSuccesfullJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSuccesfullJobResponse, error)

	PostSuccesfullJobWithResponse(ctx context.Context, body PostSuccesfullJobJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSuccesfullJobResponse, error)

	// ListWorkspacesWithResponse request
	ListWorkspacesWithResponse(ctx context.Context, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// CreateWorkspaceWithBodyWithResponse request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// DeleteWorkspaceWithResponse request
	DeleteWorkspaceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// GetWorkspaceWithResponse request
	GetWorkspaceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error)

	// ListConnectorsWithResponse request
	ListConnectorsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error)

	// DeleteConnectorWithResponse request
	DeleteConnectorWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteConnectorResponse, error)

	// GetConnectorWithResponse request
	GetConnectorWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error)

	// UpdateConnectorWithBodyWithResponse request with any body
	UpdateConnectorWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error)

	UpdateConnectorWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error)

	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// TriggerJobRunWithResponse request
	TriggerJobRunWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*TriggerJobRunResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// GetJobLogsWithResponse request
	GetJobLogsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error)

	// ListSourcesWithResponse request
	ListSourcesWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListSourcesResponse, error)

	// DeleteSourceWithResponse request
	DeleteSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error)

	// GetSourceWithResponse request
	GetSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSourceResponse, error)

	// UpdateSourceWithBodyWithResponse request with any body
	UpdateSourceWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	UpdateSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	// CreateConnectorFromSourceWithBodyWithResponse request with any body
	CreateConnectorFromSourceWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectorFromSourceResponse, error)

	CreateConnectorFromSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body CreateConnectorFromSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectorFromSourceResponse, error)

	// GetUpdateSourceStatusWithResponse request
	GetUpdateSourceStatusWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUpdateSourceStatusResponse, error)

	// GetSourceTablesWithResponse request
	GetSourceTablesWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSourceTablesResponse, error)

	// GetGetSourceTablesStatusWithResponse request
	GetGetSourceTablesStatusWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetGetSourceTablesStatusResponse, error)

	// ListSourcesDefinitionsWithResponse request
	ListSourcesDefinitionsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListSourcesDefinitionsResponse, error)

	// GetCreateSourceFromDefinitionStatusWithResponse request
	GetCreateSourceFromDefinitionStatusWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionID openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCreateSourceFromDefinitionStatusResponse, error)

	// GetSourceDefinitionConfigurationWithResponse request
	GetSourceDefinitionConfigurationWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSourceDefinitionConfigurationResponse, error)

	// CreateSourceFromDefinitionWithBodyWithResponse request with any body
	CreateSourceFromDefinitionWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceFromDefinitionResponse, error)

	CreateSourceFromDefinitionWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, body CreateSourceFromDefinitionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceFromDefinitionResponse, error)
}

type PostSuccesfullJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostSuccesfullJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSuccesfullJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkspaceList
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Workspace
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workspace
}

// Status returns HTTPResponse.Status
func (r GetWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectorsPaginated
}

// Status returns HTTPResponse.Status
func (r ListConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Connector
}

// Status returns HTTPResponse.Status
func (r GetConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Connector
}

// Status returns HTTPResponse.Status
func (r UpdateConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobList
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerJobRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Job
}

// Status returns HTTPResponse.Status
func (r TriggerJobRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerJobRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobLog
}

// Status returns HTTPResponse.Status
func (r GetJobLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SourceList
}

// Status returns HTTPResponse.Status
func (r ListSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
}

// Status returns HTTPResponse.Status
func (r GetSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncOperationResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConnectorFromSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Connector
}

// Status returns HTTPResponse.Status
func (r CreateConnectorFromSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConnectorFromSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpdateSourceStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateSourceStatus
}

// Status returns HTTPResponse.Status
func (r GetUpdateSourceStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpdateSourceStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourceTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AsyncOperationResponse
}

// Status returns HTTPResponse.Status
func (r GetSourceTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourceTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGetSourceTablesStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSourceTablesStatus
}

// Status returns HTTPResponse.Status
func (r GetGetSourceTablesStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGetSourceTablesStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourcesDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SourceDefinitionList
}

// Status returns HTTPResponse.Status
func (r ListSourcesDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourcesDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCreateSourceFromDefinitionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateSourceStatus
}

// Status returns HTTPResponse.Status
func (r GetCreateSourceFromDefinitionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCreateSourceFromDefinitionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourceDefinitionConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SourceDefinitionConfiguration
}

// Status returns HTTPResponse.Status
func (r GetSourceDefinitionConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourceDefinitionConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSourceFromDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncOperationResponse
}

// Status returns HTTPResponse.Status
func (r CreateSourceFromDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSourceFromDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostSuccesfullJobWithBodyWithResponse request with arbitrary body returning *PostSuccesfullJobResponse
func (c *ClientWithResponses) PostSuccesfullJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSuccesfullJobResponse, error) {
	rsp, err := c.PostSuccesfullJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSuccesfullJobResponse(rsp)
}

func (c *ClientWithResponses) PostSuccesfullJobWithResponse(ctx context.Context, body PostSuccesfullJobJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSuccesfullJobResponse, error) {
	rsp, err := c.PostSuccesfullJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSuccesfullJobResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, params *ListWorkspacesParams, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, workspaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// GetWorkspaceWithResponse request returning *GetWorkspaceResponse
func (c *ClientWithResponses) GetWorkspaceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWorkspaceResponse, error) {
	rsp, err := c.GetWorkspace(ctx, workspaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkspaceResponse(rsp)
}

// ListConnectorsWithResponse request returning *ListConnectorsResponse
func (c *ClientWithResponses) ListConnectorsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error) {
	rsp, err := c.ListConnectors(ctx, workspaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConnectorsResponse(rsp)
}

// DeleteConnectorWithResponse request returning *DeleteConnectorResponse
func (c *ClientWithResponses) DeleteConnectorWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteConnectorResponse, error) {
	rsp, err := c.DeleteConnector(ctx, workspaceId, connectorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConnectorResponse(rsp)
}

// GetConnectorWithResponse request returning *GetConnectorResponse
func (c *ClientWithResponses) GetConnectorWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error) {
	rsp, err := c.GetConnector(ctx, workspaceId, connectorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorResponse(rsp)
}

// UpdateConnectorWithBodyWithResponse request with arbitrary body returning *UpdateConnectorResponse
func (c *ClientWithResponses) UpdateConnectorWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error) {
	rsp, err := c.UpdateConnectorWithBody(ctx, workspaceId, connectorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorResponse(rsp)
}

func (c *ClientWithResponses) UpdateConnectorWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error) {
	rsp, err := c.UpdateConnector(ctx, workspaceId, connectorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, workspaceId, connectorId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// TriggerJobRunWithResponse request returning *TriggerJobRunResponse
func (c *ClientWithResponses) TriggerJobRunWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*TriggerJobRunResponse, error) {
	rsp, err := c.TriggerJobRun(ctx, workspaceId, connectorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerJobRunResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, workspaceId, connectorId, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// GetJobLogsWithResponse request returning *GetJobLogsResponse
func (c *ClientWithResponses) GetJobLogsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, connectorId openapi_types.UUID, jobId int64, params *GetJobLogsParams, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error) {
	rsp, err := c.GetJobLogs(ctx, workspaceId, connectorId, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobLogsResponse(rsp)
}

// ListSourcesWithResponse request returning *ListSourcesResponse
func (c *ClientWithResponses) ListSourcesWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListSourcesResponse, error) {
	rsp, err := c.ListSources(ctx, workspaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourcesResponse(rsp)
}

// DeleteSourceWithResponse request returning *DeleteSourceResponse
func (c *ClientWithResponses) DeleteSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error) {
	rsp, err := c.DeleteSource(ctx, workspaceId, sourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSourceResponse(rsp)
}

// GetSourceWithResponse request returning *GetSourceResponse
func (c *ClientWithResponses) GetSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSourceResponse, error) {
	rsp, err := c.GetSource(ctx, workspaceId, sourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourceResponse(rsp)
}

// UpdateSourceWithBodyWithResponse request with arbitrary body returning *UpdateSourceResponse
func (c *ClientWithResponses) UpdateSourceWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSourceWithBody(ctx, workspaceId, sourceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSource(ctx, workspaceId, sourceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

// CreateConnectorFromSourceWithBodyWithResponse request with arbitrary body returning *CreateConnectorFromSourceResponse
func (c *ClientWithResponses) CreateConnectorFromSourceWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectorFromSourceResponse, error) {
	rsp, err := c.CreateConnectorFromSourceWithBody(ctx, workspaceId, sourceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectorFromSourceResponse(rsp)
}

func (c *ClientWithResponses) CreateConnectorFromSourceWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, body CreateConnectorFromSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectorFromSourceResponse, error) {
	rsp, err := c.CreateConnectorFromSource(ctx, workspaceId, sourceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectorFromSourceResponse(rsp)
}

// GetUpdateSourceStatusWithResponse request returning *GetUpdateSourceStatusResponse
func (c *ClientWithResponses) GetUpdateSourceStatusWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUpdateSourceStatusResponse, error) {
	rsp, err := c.GetUpdateSourceStatus(ctx, workspaceId, sourceId, ticketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpdateSourceStatusResponse(rsp)
}

// GetSourceTablesWithResponse request returning *GetSourceTablesResponse
func (c *ClientWithResponses) GetSourceTablesWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSourceTablesResponse, error) {
	rsp, err := c.GetSourceTables(ctx, workspaceId, sourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourceTablesResponse(rsp)
}

// GetGetSourceTablesStatusWithResponse request returning *GetGetSourceTablesStatusResponse
func (c *ClientWithResponses) GetGetSourceTablesStatusWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceId openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetGetSourceTablesStatusResponse, error) {
	rsp, err := c.GetGetSourceTablesStatus(ctx, workspaceId, sourceId, ticketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGetSourceTablesStatusResponse(rsp)
}

// ListSourcesDefinitionsWithResponse request returning *ListSourcesDefinitionsResponse
func (c *ClientWithResponses) ListSourcesDefinitionsWithResponse(ctx context.Context, workspaceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListSourcesDefinitionsResponse, error) {
	rsp, err := c.ListSourcesDefinitions(ctx, workspaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourcesDefinitionsResponse(rsp)
}

// GetCreateSourceFromDefinitionStatusWithResponse request returning *GetCreateSourceFromDefinitionStatusResponse
func (c *ClientWithResponses) GetCreateSourceFromDefinitionStatusWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionID openapi_types.UUID, ticketId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCreateSourceFromDefinitionStatusResponse, error) {
	rsp, err := c.GetCreateSourceFromDefinitionStatus(ctx, workspaceId, sourceDefinitionID, ticketId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCreateSourceFromDefinitionStatusResponse(rsp)
}

// GetSourceDefinitionConfigurationWithResponse request returning *GetSourceDefinitionConfigurationResponse
func (c *ClientWithResponses) GetSourceDefinitionConfigurationWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSourceDefinitionConfigurationResponse, error) {
	rsp, err := c.GetSourceDefinitionConfiguration(ctx, workspaceId, sourceDefinitionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourceDefinitionConfigurationResponse(rsp)
}

// CreateSourceFromDefinitionWithBodyWithResponse request with arbitrary body returning *CreateSourceFromDefinitionResponse
func (c *ClientWithResponses) CreateSourceFromDefinitionWithBodyWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceFromDefinitionResponse, error) {
	rsp, err := c.CreateSourceFromDefinitionWithBody(ctx, workspaceId, sourceDefinitionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceFromDefinitionResponse(rsp)
}

func (c *ClientWithResponses) CreateSourceFromDefinitionWithResponse(ctx context.Context, workspaceId openapi_types.UUID, sourceDefinitionId openapi_types.UUID, body CreateSourceFromDefinitionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceFromDefinitionResponse, error) {
	rsp, err := c.CreateSourceFromDefinition(ctx, workspaceId, sourceDefinitionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceFromDefinitionResponse(rsp)
}

// ParsePostSuccesfullJobResponse parses an HTTP response from a PostSuccesfullJobWithResponse call
func ParsePostSuccesfullJobResponse(rsp *http.Response) (*PostSuccesfullJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSuccesfullJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkspaceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkspaceResponse parses an HTTP response from a GetWorkspaceWithResponse call
func ParseGetWorkspaceResponse(rsp *http.Response) (*GetWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListConnectorsResponse parses an HTTP response from a ListConnectorsWithResponse call
func ParseListConnectorsResponse(rsp *http.Response) (*ListConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectorsPaginated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteConnectorResponse parses an HTTP response from a DeleteConnectorWithResponse call
func ParseDeleteConnectorResponse(rsp *http.Response) (*DeleteConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConnectorResponse parses an HTTP response from a GetConnectorWithResponse call
func ParseGetConnectorResponse(rsp *http.Response) (*GetConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Connector
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConnectorResponse parses an HTTP response from a UpdateConnectorWithResponse call
func ParseUpdateConnectorResponse(rsp *http.Response) (*UpdateConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Connector
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTriggerJobRunResponse parses an HTTP response from a TriggerJobRunWithResponse call
func ParseTriggerJobRunResponse(rsp *http.Response) (*TriggerJobRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerJobRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobLogsResponse parses an HTTP response from a GetJobLogsWithResponse call
func ParseGetJobLogsResponse(rsp *http.Response) (*GetJobLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSourcesResponse parses an HTTP response from a ListSourcesWithResponse call
func ParseListSourcesResponse(rsp *http.Response) (*ListSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SourceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSourceResponse parses an HTTP response from a DeleteSourceWithResponse call
func ParseDeleteSourceResponse(rsp *http.Response) (*DeleteSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSourceResponse parses an HTTP response from a GetSourceWithResponse call
func ParseGetSourceResponse(rsp *http.Response) (*GetSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSourceResponse parses an HTTP response from a UpdateSourceWithResponse call
func ParseUpdateSourceResponse(rsp *http.Response) (*UpdateSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseCreateConnectorFromSourceResponse parses an HTTP response from a CreateConnectorFromSourceWithResponse call
func ParseCreateConnectorFromSourceResponse(rsp *http.Response) (*CreateConnectorFromSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConnectorFromSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Connector
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetUpdateSourceStatusResponse parses an HTTP response from a GetUpdateSourceStatusWithResponse call
func ParseGetUpdateSourceStatusResponse(rsp *http.Response) (*GetUpdateSourceStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpdateSourceStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateSourceStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSourceTablesResponse parses an HTTP response from a GetSourceTablesWithResponse call
func ParseGetSourceTablesResponse(rsp *http.Response) (*GetSourceTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourceTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AsyncOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGetSourceTablesStatusResponse parses an HTTP response from a GetGetSourceTablesStatusWithResponse call
func ParseGetGetSourceTablesStatusResponse(rsp *http.Response) (*GetGetSourceTablesStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGetSourceTablesStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSourceTablesStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSourcesDefinitionsResponse parses an HTTP response from a ListSourcesDefinitionsWithResponse call
func ParseListSourcesDefinitionsResponse(rsp *http.Response) (*ListSourcesDefinitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourcesDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SourceDefinitionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCreateSourceFromDefinitionStatusResponse parses an HTTP response from a GetCreateSourceFromDefinitionStatusWithResponse call
func ParseGetCreateSourceFromDefinitionStatusResponse(rsp *http.Response) (*GetCreateSourceFromDefinitionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCreateSourceFromDefinitionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateSourceStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSourceDefinitionConfigurationResponse parses an HTTP response from a GetSourceDefinitionConfigurationWithResponse call
func ParseGetSourceDefinitionConfigurationResponse(rsp *http.Response) (*GetSourceDefinitionConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourceDefinitionConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SourceDefinitionConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSourceFromDefinitionResponse parses an HTTP response from a CreateSourceFromDefinitionWithResponse call
func ParseCreateSourceFromDefinitionResponse(rsp *http.Response) (*CreateSourceFromDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSourceFromDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncOperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}
